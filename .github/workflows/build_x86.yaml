#
# Copyright (c) 2023 Savva Mitrofanov. All rights reserved.<BR>
# Copyright (c) 2023 Marvin HÃ¤user. All rights reserved.<BR>
# SPDX-License-Identifier: BSD-2-Clause-Patent
#

name: Build X86 Firmwares (Repro)

on:
  push:
  pull_request:
  workflow_dispatch:
  release:
    types: [published]

jobs:
  build-linux-clangpdb:
    name: Linux CLANGPDB
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Use Docker in rootless mode.
        uses: ScribeMD/rootless-docker@0.2.2

      - name: Download ue-dev Docker Image
        uses: robinraju/release-downloader@v1.7
        with:
          repository: "mhaeuser/MastersThesis"
          tag: "ue-dev-release"
          fileName: "ue-dev.tar.xz"

      - name: Set up ue-dev Docker Image
        run: |
          docker load -i ue-dev.tar.xz
          rm -f ue-dev.tar.xz

      - name: Build BaseTools
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: make -j -C BaseTools

      - name: Build OvmfPkgIa32
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgIa32.dsc -t CLANGPDB -a IA32 -b RELEASE -b DEBUG -b NOOPT -D WINDOWS_10_IA32

      - name: Build OvmfPkgX64
        if: always()
        run: docker compose run edk2-build
        env:
          # FIXME: NOOPT SECFV is too large
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgX64.dsc -t CLANGPDB -a X64 -b RELEASE -b DEBUG -D WINDOWS_10_IA32

      - name: Build OvmfPkgIa32X64
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgIa32X64.dsc -t CLANGPDB -a IA32 -a X64 -b RELEASE -b DEBUG -b NOOPT

      - name: Prepare artifacts with firmwares (Ia32,3264)
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              mkdir -p ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"
              cp ./audk/Build/Ovmf"$arch"/"$target"_"$TOOLCHAIN"/FV/OVMF.fd ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"/FW.fd
              done
          done
        env:
          ARCHS: Ia32,3264
          TARGETS: RELEASE,DEBUG,NOOPT
          TOOLCHAIN: CLANGPDB

      # FIXME: NOOPT SECFV is too large
      - name: Prepare artifacts with firmwares (X64)
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              mkdir -p ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"
              cp ./audk/Build/Ovmf"$arch"/"$target"_"$TOOLCHAIN"/FV/OVMF.fd ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"/FW.fd
              done
          done
        env:
          ARCHS: X64
          TARGETS: RELEASE,DEBUG
          TOOLCHAIN: CLANGPDB

      - name: Prepare artifacts with images (Ia32)
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              ovmf_arch="$arch"
              if [ "$ovmf_arch" = "IA32" ]; then
                ovmf_arch="Ia32"
              fi
              mkdir -p ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              cp ./audk/Build/Ovmf"$ovmf_arch"/"$target"_"$TOOLCHAIN"/"$arch"/*.efi ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              done
          done
        env:
          ARCHS: IA32
          # FIXME: NOOPT SECFV is too large
          TARGETS: RELEASE,DEBUG,NOOPT
          TOOLCHAIN: CLANGPDB

      - name: Prepare artifacts with images (X64)
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              ovmf_arch="$arch"
              if [ "$ovmf_arch" = "IA32" ]; then
                ovmf_arch="Ia32"
              fi
              mkdir -p ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              cp ./audk/Build/Ovmf"$ovmf_arch"/"$target"_"$TOOLCHAIN"/"$arch"/*.efi ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              done
          done
        env:
          ARCHS: X64
          # FIXME: NOOPT SECFV is too large
          TARGETS: RELEASE,DEBUG
          TOOLCHAIN: CLANGPDB

      - name: Zip artifacts
        run: |
          mkdir Binaries/
          zip Binaries/CLANGPDB_fw_x86_artifacts.zip ./firmware_artifacts/* -r
          zip Binaries/CLANGPDB_img_x86_artifacts.zip ./image_artifacts/* -r

      - name: Upload to Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: CLANGPDB Firmware X86 Artifacts
          path: Binaries/CLANGPDB_fw_x86_artifacts.zip

      - name: Upload images to Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: CLANGPDB Image X86 Artifacts
          path: Binaries/CLANGPDB_img_x86_artifacts.zip

      - name: Upload to Release
        if: github.event_name == 'release'
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: Binaries/*
          tag: ${{ github.ref }}
          file_glob: true

  build-linux-clangdwarf:
    name: Linux CLANGDWARF
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Use Docker in rootless mode.
        uses: ScribeMD/rootless-docker@0.2.2

      - name: Download ue-dev Docker Image
        uses: robinraju/release-downloader@v1.7
        with:
          repository: "mhaeuser/MastersThesis"
          tag: "ue-dev-release"
          fileName: "ue-dev.tar.xz"

      - name: Set up ue-dev Docker Image
        run: |
          docker load -i ue-dev.tar.xz
          rm -f ue-dev.tar.xz
  
      - name: Build BaseTools
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: make -j -C BaseTools

      - name: Build OvmfPkgIa32
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgIa32.dsc -t CLANGDWARF -a IA32 -b RELEASE -b DEBUG -b NOOPT -D WINDOWS_10_IA32

      - name: Build OvmfPkgX64
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgX64.dsc -t CLANGDWARF -a X64 -b RELEASE -b DEBUG -b NOOPT

      - name: Build OvmfPkgIa32X64
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgIa32X64.dsc -t CLANGDWARF -a IA32 -a X64 -b RELEASE -b DEBUG -b NOOPT

      - name: Prepare artifacts with firmwares
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              mkdir -p ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"
              cp ./audk/Build/Ovmf"$arch"/"$target"_"$TOOLCHAIN"/FV/OVMF.fd ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"/FW.fd
              done
          done
        env:
          ARCHS: Ia32,X64,3264
          TARGETS: RELEASE,DEBUG,NOOPT
          TOOLCHAIN: CLANGDWARF

      - name: Prepare artifacts with images
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              ovmf_arch="$arch"
              if [ "$ovmf_arch" = "IA32" ]; then
                ovmf_arch="Ia32"
              fi
              mkdir -p ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              cp ./audk/Build/Ovmf"$ovmf_arch"/"$target"_"$TOOLCHAIN"/"$arch"/*.efi ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              done
          done
        env:
          ARCHS: IA32,X64
          TARGETS: RELEASE,DEBUG,NOOPT
          TOOLCHAIN: CLANGDWARF

      - name: Zip artifacts
        run: |
          mkdir Binaries/
          zip Binaries/CLANGDWARF_fw_x86_artifacts.zip ./firmware_artifacts/* -r
          zip Binaries/CLANGDWARF_img_x86_artifacts.zip ./image_artifacts/* -r

      - name: Upload firmware to Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: CLANGDWARF Firmware X86 Artifacts
          path: Binaries/CLANGDWARF_fw_x86_artifacts.zip

      - name: Upload images to Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: CLANGDWARF Image X86 Artifacts
          path: Binaries/CLANGDWARF_img_x86_artifacts.zip

      - name: Upload to Release
        if: github.event_name == 'release'
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: Binaries/*
          tag: ${{ github.ref }}
          file_glob: true

  build-linux-gcc5:
    name: Linux GCC5
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Use Docker in rootless mode.
        uses: ScribeMD/rootless-docker@0.2.2

      - name: Download ue-dev Docker Image
        uses: robinraju/release-downloader@v1.7
        with:
          repository: "mhaeuser/MastersThesis"
          tag: "ue-dev-release"
          fileName: "ue-dev.tar.xz"

      - name: Set up ue-dev Docker Image
        run: |
          docker load -i ue-dev.tar.xz
          rm -f ue-dev.tar.xz

      - name: Build BaseTools
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: make -j -C BaseTools

      - name: Build OvmfPkgIa32
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgIa32.dsc -t GCC5 -a IA32 -b RELEASE -b DEBUG -b NOOPT -D WINDOWS_10_IA32

      - name: Build OvmfPkgX64
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgX64.dsc -t GCC5 -a X64 -b RELEASE -b DEBUG -b NOOPT

      - name: Build OvmfPkgIa32X64
        if: always()
        run: docker compose run edk2-build
        env:
          EDK2_BUILD_CMD: build -p OvmfPkg/OvmfPkgIa32X64.dsc -t GCC5 -a IA32 -a X64 -b RELEASE -b DEBUG -b NOOPT

      - name: Prepare artifacts with firmwares
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              mkdir -p ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"
              cp ./audk/Build/Ovmf"$arch"/"$target"_"$TOOLCHAIN"/FV/OVMF.fd ./firmware_artifacts/Ovmf/"$arch"/"$target"_"$TOOLCHAIN"/FW.fd
              done
          done
        env:
          ARCHS: Ia32,X64,3264
          TARGETS: RELEASE,DEBUG,NOOPT
          TOOLCHAIN: GCC5

      - name: Prepare artifacts with images
        if: always()
        run: |
          IFS=', ' read -r -a TARGETS <<< "$TARGETS"
          IFS=', ' read -r -a ARCHS <<< "$ARCHS"
          for target in "${TARGETS[@]}"; do
            for arch in "${ARCHS[@]}"; do
              ovmf_arch="$arch"
              if [ "$ovmf_arch" = "IA32" ]; then
                ovmf_arch="Ia32"
              fi
              mkdir -p ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              cp ./audk/Build/Ovmf"$ovmf_arch"/"$target"_"$TOOLCHAIN"/"$arch"/*.efi ./image_artifacts/Ovmf/"$target"_"$TOOLCHAIN"/"$arch"/
              done
          done
        env:
          ARCHS: IA32,X64
          TARGETS: RELEASE,DEBUG,NOOPT
          TOOLCHAIN: GCC5

      - name: Zip artifacts
        run: |
          mkdir Binaries/
          zip Binaries/GCC5_fw_x86_artifacts.zip ./firmware_artifacts/* -r
          zip Binaries/GCC5_img_x86_artifacts.zip ./image_artifacts/* -r

      - name: Upload firmware to Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: GCC5 Firmware X86 Artifacts
          path: Binaries/GCC5_fw_x86_artifacts.zip

      - name: Upload images to Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: GCC5 Image X86 Artifacts
          path: Binaries/GCC5_img_x86_artifacts.zip

      - name: Upload to Release
        if: github.event_name == 'release'
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: Binaries/*
          tag: ${{ github.ref }}
          file_glob: true

  test-firmwares:
    name: Test
    runs-on: ubuntu-22.04
    needs: [build-linux-clangpdb, build-linux-clangdwarf, build-linux-gcc5]

    strategy:
      fail-fast: false
      matrix:
        package: [
          # FIXME: NOOPT SECFV is too large
          {name: "Ovmf", archs: "Ia32,X64,3264", toolchain: "CLANGPDB", targets: "RELEASE,DEBUG"},
          {name: "Ovmf", archs: "Ia32,X64,3264", toolchain: "CLANGDWARF", targets: "RELEASE,DEBUG,NOOPT"},
          {name: "Ovmf", archs: "Ia32,X64,3264", toolchain: "GCC5", targets: "RELEASE,DEBUG,NOOPT"},
        ]
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Use Docker in rootless mode.
        uses: ScribeMD/rootless-docker@0.2.2

      - name: Download ue-dev Docker Image
        uses: robinraju/release-downloader@v1.7
        with:
          repository: "mhaeuser/MastersThesis"
          tag: "ue-dev-release"
          fileName: "ue-dev.tar.xz"

      - name: Set up ue-dev Docker Image
        run: |
          docker load -i ue-dev.tar.xz
          rm -f ue-dev.tar.xz

      - name: Download a single artifact
        uses: actions/download-artifact@v3
        with:
          name: ${{ matrix.package.toolchain }} Firmware X86 Artifacts

      - name: Unzip artifacts
        run: unzip "$TOOLCHAIN"_fw_x86_artifacts.zip
        env:
          TOOLCHAIN: ${{ matrix.package.toolchain }}

      - name: Downloading Windows PE X64 iso
        uses: robinraju/release-downloader@v1.7
        with:
          repository: "acidanthera/OcBinaryData"
          tag: "images-winpe-1.0"
          fileName: "winpe_X64.iso"

      - name: Downloading Windows PE IA32 iso
        uses: robinraju/release-downloader@v1.7
        with:
          repository: "acidanthera/OcBinaryData"
          tag: "images-winpe-1.0"
          fileName: "winpe_IA32.iso"

      - name: Run TestConsole
        if: always()
        run: docker compose run edk2-test
        env:
          EDK2_TEST_CMD: ./Scripts/test_console.sh
          PACKAGE: ${{ matrix.package.name }}
          ARCHS: ${{ matrix.package.archs }}
          TARGETS: ${{ matrix.package.targets }}
          TOOLCHAIN: ${{ matrix.package.toolchain }}

      - name: Run TestLinux
        if: always()
        run: docker compose run edk2-test
        env:
          EDK2_TEST_CMD: ./Scripts/test_linux.sh
          PACKAGE: ${{ matrix.package.name }}
          ARCHS: ${{ matrix.package.archs }}
          TARGETS: ${{ matrix.package.targets }}
          TOOLCHAIN: ${{ matrix.package.toolchain }}

      - name: Run Windows PE
        if: always()
        run: docker compose run edk2-test
        env:
          EDK2_TEST_CMD: ./Scripts/test_windows.sh
          PACKAGE: ${{ matrix.package.name }}
          ARCHS: ${{ matrix.package.archs }}
          TARGETS: ${{ matrix.package.targets }}
          TOOLCHAIN: ${{ matrix.package.toolchain }}
